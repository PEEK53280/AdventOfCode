# Tag 09 - Computational Geometry mit Shapely

## Aufgabe

Gegeben ist ein Polygon aus Punkten. Finde Rechtecke, die durch Punktpaare definiert werden:
- **Teil 1:** Größte Fläche eines Rechtecks zwischen zwei beliebigen Punkten
- **Teil 2:** Größte Fläche eines Rechtecks, das vollständig im Polygon enthalten ist

## Lösung

### Eingabeformat

Jede Zeile enthält einen Punkt als `x,y` Koordinaten:
```
0,0
5,0
5,5
0,5
```

Die Punkte definieren ein Polygon in der Reihenfolge ihrer Eingabe.

### Abhängigkeiten

```python
import shapely
```

**Shapely:**
- Externe Bibliothek für geometrische Operationen
- Installation: `pip install shapely>=2.0.0`
- Siehe `requirements.txt` und README.md

**Warum Shapely?**
- Präzise Polygon-Operationen
- Point-in-Polygon Tests
- Robuste Implementierungen komplexer Algorithmen
- **Versuchte stdlib-Alternative:** 4x langsamer, falsche Ergebnisse

### Algorithmus

```python
def main():
    punkte = [tuple(map(int, zeile.strip().split(','))) for zeile in aufgabe.zeilen]
    poly = shapely.Polygon(punkte)
    for (x1, y1), (x2, y2) in itertools.combinations(punkte, 2):
        fläche = (abs(x1 - x2) + 1) * (abs(y1 - y2) + 1)
        aufgabe.loesung1 = max(aufgabe.loesung1, fläche)
        rect = shapely.box(min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2))
        aufgabe.loesung2 = max(aufgabe.loesung2, fläche) if poly.contains(rect) else aufgabe.loesung2
```

### Funktionsweise

#### 1. Punkte parsen

```python
punkte = [tuple(map(int, zeile.strip().split(','))) for zeile in aufgabe.zeilen]
```

**Logik:**
- Jede Zeile: `"x,y"` → Split bei `","` → `["x", "y"]`
- `map(int, ...)`: Konvertiere zu Integers
- `tuple(...)`: Konvertiere zu Tuple `(x, y)`
- Ergebnis: Liste von Punkt-Tupeln

**Beispiel:** `"5,10"` → `(5, 10)`

#### 2. Polygon erstellen

```python
poly = shapely.Polygon(punkte)
```

**Shapely Polygon:**
- Erstellt Polygon aus Punktliste
- Punkte werden in Reihenfolge verbunden
- Letzter Punkt wird automatisch mit erstem verbunden
- **Wichtig:** Reihenfolge der Punkte definiert Polygon-Form

**Beispiel:**
```python
punkte = [(0,0), (5,0), (5,5), (0,5)]
poly = shapely.Polygon(punkte)  # Quadrat
```

#### 3. Alle Punktpaare testen

```python
for (x1, y1), (x2, y2) in itertools.combinations(punkte, 2):
```

**itertools.combinations:**
- Generiert alle 2er-Kombinationen der Punkte
- Keine Duplikate, keine Selbst-Paare
- **Anzahl:** n * (n-1) / 2 Paare

**Unpacking:**
- `(x1, y1), (x2, y2)`: Direkt Koordinaten extrahieren
- Eleganter als Index-Zugriff

#### 4. Fläche berechnen

```python
fläche = (abs(x1 - x2) + 1) * (abs(y1 - y2) + 1)
```

**Rechteck-Fläche:**
- Breite: `abs(x1 - x2) + 1`
- Höhe: `abs(y1 - y2) + 1`
- **+1 wichtig:** Inklusive Grenzen

**Warum +1?**
- Punkte auf Gitter-Koordinaten
- Rechteck von (0,0) bis (2,0) hat Breite 3, nicht 2
- Zählt Gitter-Punkte, nicht Abstände

**Beispiel:**
- Punkte: (1, 1) und (3, 4)
- Breite: `abs(1 - 3) + 1 = 3`
- Höhe: `abs(1 - 4) + 1 = 4`
- Fläche: `3 * 4 = 12`

#### 5. Teil 1 - Größte Fläche

```python
aufgabe.loesung1 = max(aufgabe.loesung1, fläche)
```

**Logik:**
- Speichere Maximum aller Flächen
- Keine Bedingungen, **alle** Punktpaare zählen
- Auch Rechtecke außerhalb des Polygons

#### 6. Rechteck-Objekt erstellen

```python
rect = shapely.box(min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2))
```

**shapely.box:**
- Erstellt achsenparalleles Rechteck
- Parameter: `(min_x, min_y, max_x, max_y)`
- `min/max`: Garantiert korrekte Reihenfolge (unabhängig von Punkt-Reihenfolge)

**Beispiel:**
```python
# Punkte: (3, 4) und (1, 1)
rect = shapely.box(1, 1, 3, 4)  # Immer min zuerst, dann max
```

#### 7. Teil 2 - Fläche wenn im Polygon enthalten

```python
aufgabe.loesung2 = max(aufgabe.loesung2, fläche) if poly.contains(rect) else aufgabe.loesung2
```

**poly.contains(rect):**
- Shapely Methode für Containment-Test
- Prüft ob Rechteck **vollständig** im Polygon liegt
- **Nicht:** Ob es sich nur überschneidet

**Conditional Maximum:**
- Wenn enthalten: `max(loesung2, fläche)`
- Wenn nicht: `loesung2` (unverändert)
- Ternary Operator für kompakte Schreibweise

**Wichtige Unterscheidung:**
- `poly.contains(rect)`: Rechteck vollständig drin
- `poly.intersects(rect)`: Rechteck berührt Polygon
- Hier wird `contains` benötigt!

### Beispiel-Durchlauf

**Eingabe:**
```
0,0
4,0
4,4
0,4
```

**Polygon:** Quadrat von (0,0) bis (4,4)

**Punktpaare (Auswahl):**

1. **Paar: (0,0) und (4,4)**
   - Fläche: `(4 + 1) * (4 + 1) = 25`
   - Rechteck: `box(0, 0, 4, 4)`
   - Enthalten: Ja (genau das Polygon)
   - Lösungen: `loesung1 = 25`, `loesung2 = 25`

2. **Paar: (0,0) und (4,0)**
   - Fläche: `(4 + 1) * (0 + 1) = 5`
   - Rechteck: `box(0, 0, 4, 0)` (Linie)
   - Enthalten: Ja (Polygon-Kante)
   - Lösungen: `loesung1 = 25`, `loesung2 = 25`

3. **Hypothetisch: (0,0) und (10,10) (Punkt außerhalb)**
   - Fläche: `(10 + 1) * (10 + 1) = 121`
   - Rechteck: `box(0, 0, 10, 10)`
   - Enthalten: Nein (größer als Polygon)
   - Lösungen: `loesung1 = 121`, `loesung2 = 25`

**Endergebnis:**
- `loesung1 = 121` (größte Fläche insgesamt)
- `loesung2 = 25` (größte Fläche im Polygon)

### Komplexität

**Parse:**
- Zeit: O(n) wobei n = Anzahl Punkte
- Platz: O(n)

**Polygon-Erstellung:**
- Zeit: O(n)
- Shapely interne Datenstruktur-Aufbau

**Alle Paare:**
- Zeit: O(n²) Paare
- Pro Paar:
  - Fläche berechnen: O(1)
  - Rechteck erstellen: O(1)
  - Containment-Test: O(m) wobei m = Polygon-Komplexität

**Gesamt:**
- Zeit: O(n + n² * m) ≈ O(n² * m)
- Platz: O(n + m) für Datenstrukturen

**m (Polygon-Komplexität):**
- Für einfache Polygone: m ≈ n
- Shapely optimiert Containment-Tests
- Praktisch sehr schnell

### Besonderheiten

**Inklusive Gitter-Punkte:**
- `+1` bei Flächen-Berechnung
- Unterschied zu kontinuierlicher Geometrie
- Wichtig für korrekte Zählung

**Shapely vs. stdlib:**
- Versuchte Alternative: Ray-casting für Point-in-Polygon
- Ergebnis: 4x langsamer (11s vs. 2.5s)
- Falsche Ergebnisse bei komplexen Fällen
- **Fazit:** Shapely ist notwendig für Korrektheit und Performance

**Achsenparallele Rechtecke:**
- Nur horizontale/vertikale Seiten
- `shapely.box` garantiert dies
- Vereinfacht Berechnungen

**Polygon-Reihenfolge:**
- Punkte definieren Polygon durch Verbindung
- Falsche Reihenfolge → Selbstüberschneidendes Polygon
- Shapely erkennt solche Probleme

**Containment-Semantik:**
- Kanten zählen als "enthalten"
- Rechteck kann Polygon-Grenze berühren
- Wichtig für Grenzfälle

**itertools.combinations:**
- Effizienter als nested loops
- Automatisch keine Duplikate
- Pythonischer Code-Stil

**Max-Tracking:**
- Beide Lösungen starten bei 0 (default in GetData)
- `max(current, new)` Pattern für Tracking
- Kein separates Maximum nötig

### Performance-Hinweise

Für große Punktmengen:
1. **Frühe Grenzen-Prüfung:** Überspringe Punkte außerhalb bounding box
2. **Spatial Indexing:** Shapely STRtree für schnellere Queries
3. **Polygon-Simplification:** Reduziere Polygon-Komplexität wenn möglich

Für dieses Problem:
- Shapely ist optimal
- Keine weitere Optimierung nötig
- 2.5s Laufzeit ist akzeptabel
