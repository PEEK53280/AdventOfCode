# Tag 04 - Zellenautomaten-Simulation

## Aufgabe

Simulation einer Karte mit `@` Symbolen, die "wegrollen", wenn sie nicht genug Nachbarn haben.

- **Teil 1:** Anzahl der `@` die in der ersten Iteration verschwinden
- **Teil 2:** Gesamtanzahl aller `@` die im gesamten Prozess verschwinden

## Lösung

### Eingabeformat

Eine 2D-Karte mit:
- `@`: Gefüllte Zellen
- `.`: Leere Zellen

Beispiel:
```
....@....
...@@@...
..@@@@@..
```

### Algorithmus

Die Simulation läuft in zwei Phasen pro Iteration:

#### 1. Horizontale Nachbarn zählen

```python
def horizontaler_zaehler(karte:list) -> list:
    reihen = [[0] * len(aufgabe.zeilen[0])]
    for zeile in karte:
        reihe = []
        for i, element in enumerate(zeile):
            horizontale_rollen = 1 if i > 0 and zeile[i - 1] == "@" else 0
            horizontale_rollen += 1 if i < len(zeile) - 1 and zeile[i + 1] == "@" else 0
            horizontale_rollen = -(horizontale_rollen + 1) if element == "@" else horizontale_rollen
            reihe.append(horizontale_rollen)
        reihen.append(reihe)
    reihen.append([0] * len(aufgabe.zeilen[0]))
    return reihen
```

**Logik für jede Zelle:**

1. **Leere Zellen (`.`):**
   - Zähle horizontale `@` Nachbarn (links/rechts)
   - Wert: `0`, `1` oder `2`

2. **Gefüllte Zellen (`@`):**
   - Zähle horizontale `@` Nachbarn
   - Speichere als **negative Zahl:** `-(anzahl + 1)`
   - Beispiele:
     - 0 horizontale Nachbarn → `-1`
     - 1 horizontaler Nachbar → `-2`
     - 2 horizontale Nachbarn → `-3`

**Padding:**
- Erste Reihe: `[0, 0, 0, ...]` (Schutz vor Index-Fehlern)
- Letzte Reihe: `[0, 0, 0, ...]`

#### 2. Vertikale Prüfung und Rollen

```python
def vertikaler_zaehler(karte:list) -> list:
    neue_reihen = []
    zaehler = 0
    for i, reihe in enumerate(karte):
        if i == 0 or i == len(karte) - 1:
            continue
        neue_reihe = ""
        for element, vor, nach in zip(reihe, karte[i - 1], karte[i + 1]):
            if element >= 0:
                neue_reihe += "."
                continue
            rollen = abs(element) - 1 + abs(vor) + abs(nach)
            if rollen >= 4:
                neue_reihe += "@"
                continue
            neue_reihe += "."
            zaehler += 1
        neue_reihen.append(neue_reihe)
    aufgabe.zaehler = zaehler
    return neue_reihen
```

**Logik:**

1. **Ignoriere Padding:** Überspringe erste und letzte Reihe

2. **Für jede Zelle:**

   **Fall A: Leere Zelle (element >= 0):**
   - Bleibt leer: `.`

   **Fall B: Gefüllte Zelle (element < 0):**
   - Berechne Gesamtzahl der Nachbarn:
     ```python
     rollen = abs(element) - 1 + abs(vor) + abs(nach)
     ```
     - `abs(element) - 1`: Anzahl horizontale Nachbarn
     - `abs(vor)`: Wert der Zelle darüber (kann `@` Nachbarn enthalten)
     - `abs(nach)`: Wert der Zelle darunter

   - **Wenn `rollen >= 4`:** Genug Nachbarn → Bleibt: `@`
   - **Wenn `rollen < 4`:** Zu wenig Nachbarn → Rollt weg: `.`
     - Zähler wird erhöht

### Beispiel-Durchlauf

**Eingangskarte:**
```
...@...
..@@@..
...@...
```

**Nach horizontaler_zaehler:**
```
[0, 0, 0, 0, 0, 0, 0]  ← Padding
[0, 0, 0, -1, 0, 0, 0]  (mittleres @ hat 0 horizontale Nachbarn)
[0, 0, -2, -3, -2, 0, 0]  (mittleres @ hat 2, äußere haben je 1)
[0, 0, 0, -1, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0]  ← Padding
```

**Vertikale Prüfung (Zeile 2: `[0, 0, -2, -3, -2, 0, 0]`):**

Position 2 (Wert `-2`):
- `rollen = abs(-2) - 1 + abs(0) + abs(0) = 1 + 0 + 0 = 1`
- `1 < 4` → Rollt weg (`.`)

Position 3 (Wert `-3`):
- `rollen = abs(-3) - 1 + abs(-1) + abs(-1) = 2 + 1 + 1 = 4`
- `4 >= 4` → Bleibt (`@`)

Position 4 (Wert `-2`):
- `rollen = abs(-2) - 1 + abs(0) + abs(0) = 1 + 0 + 0 = 1`
- `1 < 4` → Rollt weg (`.`)

**Neue Karte:**
```
...@...
...@...
...@...
```

### Hauptschleife

```python
def main():
    karte = aufgabe.zeilen
    i = 0
    while i == 0 or aufgabe.zaehler > 0:
        i += 1
        karte_mit_zahlen = horizontaler_zaehler(karte)
        karte = vertikaler_zaehler(karte_mit_zahlen)
        aufgabe.loesung2 += aufgabe.zaehler
        if i == 1:
            aufgabe.loesung1 = aufgabe.zaehler
```

**Ablauf:**

1. **Iteration 1:**
   - Läuft immer (`i == 0`)
   - Speichere Anzahl weggerollter `@` in `loesung1`

2. **Weitere Iterationen:**
   - Wiederhole solange `zaehler > 0` (noch `@` rollen weg)
   - Addiere weggerollte `@` zu `loesung2`

3. **Ende:**
   - Wenn keine `@` mehr wegrollen (`zaehler == 0`)
   - Stabile Konfiguration erreicht

### Nachbar-Regel

Ein `@` braucht **mindestens 4 Nachbarn** zum Überleben:

**Mögliche Nachbarn:**
- Links: 0 oder 1
- Rechts: 0 oder 1
- Oben: 0-3 (abhängig von horizontalen Nachbarn der oberen Zelle)
- Unten: 0-3 (abhängig von horizontalen Nachbarn der unteren Zelle)

**Stabiles `@`:** Mindestens 4 in Summe

### Komplexität

- **Zeit:** O(n * m * k) wobei n = Höhe, m = Breite, k = Anzahl Iterationen
  - Pro Iteration: Zwei Durchläufe durch gesamte Karte
  - k ist abhängig von der Eingabe (bis Stabilität)
- **Platz:** O(n * m) für Karte-Speicherung

### Besonderheiten

- **Negative Kodierung:** `@` Zellen werden negativ gespeichert, um sie von leeren zu unterscheiden
- **Zwei-Phasen-Algorithmus:** Trennung von horizontaler und vertikaler Berechnung
- **Padding-Reihen:** Vereinfachen Grenzfall-Behandlung (keine Index-Prüfungen nötig)
- **Zellenautomaten-Prinzip:** Regeln basieren auf lokalem Zustand (Nachbarschaft)
- **Konvergenz:** System stabilisiert sich irgendwann (kein `@` rollt mehr weg)
