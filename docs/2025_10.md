# Tag 10 - Lineare Gleichungssysteme (GF(2) & MILP)

## Aufgabe

Maschinen-Initialisierung mit Indikatorlichtern und Knöpfen:
- **Teil 1:** Minimale Knopfdrücke um Lichter zu togglen (0/1) auf Zielzustand
- **Teil 2:** Minimale Knopfdrücke um Zähler (natürliche Zahlen) auf Zielwerte zu erhöhen

## Lösung

### Eingabeformat

Jede Zeile beschreibt eine Maschine:
```
[.##.] (3) (1,3) (2) (2,3) (0,2) (0,1) {3,5,4,7}
```

**Komponenten:**
- `[.##.]`: Zielzustand der Lichter (`.` = aus, `#` = an)
- `(3)`, `(1,3)`, etc.: Knöpfe mit betroffenen Indizes
- `{3,5,4,7}`: Ziel-Joltage-Werte (nur Teil 2)

### Abhängigkeiten

```python
import numpy as np
from scipy.optimize import milp, LinearConstraint, Bounds
```

**NumPy & SciPy:**
- NumPy für Matrix-Operationen
- SciPy MILP für Integer Linear Programming
- Installation: `pip install numpy scipy`

### Algorithmus

#### Teil 1: Brute-Force über GF(2)

```python
def finde_minimale_druecke_toggle(ziel, knoepfe):
    n_lichter, n_knoepfe = len(ziel), len(knoepfe)
    beste = float('inf')
    for maske in range(1 << n_knoepfe):
        zustand = [0] * n_lichter
        for i, k in enumerate(knoepfe):
            if maske & (1 << i):
                for idx in k:
                    if idx < n_lichter:
                        zustand[idx] ^= 1
        if zustand == ziel:
            beste = min(beste, maske.bit_count())
    return beste if beste != float('inf') else 0
```

**Warum Brute-Force?**
- Kleine Problemgröße (~10-13 Knöpfe)
- 2^13 = 8192 Kombinationen → schnell genug
- Einfacher als Gaussian Elimination
- Garantiert optimale Lösung

#### Teil 2: Mixed Integer Linear Programming

```python
def finde_minimale_druecke_joltage(ziel_joltage, knoepfe):
    n_zaehler, n_knoepfe = len(ziel_joltage), len(knoepfe)
    matrix = np.zeros((n_zaehler, n_knoepfe))
    for i, z in enumerate(knoepfe):
        matrix[[j for j in z if j < n_zaehler], i] = 1

    result = milp(c=np.ones(n_knoepfe),
                  constraints=LinearConstraint(matrix, ziel_joltage, ziel_joltage),
                  bounds=Bounds(0, np.inf),
                  integrality=np.ones(n_knoepfe))

    return int(np.sum(result.x)) if result.success else 0
```

**Warum MILP?**
- Problem ist Integer Linear Program
- Minimiere: sum(x_i) wobei x_i = Anzahl Drücke von Knopf i
- Constraints: A * x = b wobei x ≥ 0, x ∈ ℕ
- SciPy's MILP findet optimale ganzzahlige Lösung

### Funktionsweise

#### 1. Parse Zeile

```python
ziel = [1 if c == '#' else 0 for c in zeile[zeile.index('[')+1:zeile.index(']')]]
knoepfe = [list(map(int, zeile[i+1:zeile.index(')', i)].split(',')))
           for i in range(len(zeile)) if zeile[i] == '(']
```

**Logik:**
- Ziel: Extrahiere Zeichen zwischen `[` und `]`, mappe zu 0/1
- Knöpfe: Finde alle `(...)` Gruppen, parse Zahlen

**Beispiel:** `[.##.]` → `[0,1,1,0]`

#### 2. Teil 1 - Bit-Masken Iteration

```python
for maske in range(1 << n_knoepfe):
```

**Bit-Maske:**
- Jedes Bit repräsentiert einen Knopf (0 = nicht drücken, 1 = drücken)
- `1 << n` erstellt 2^n Kombinationen
- Iteriert durch alle möglichen Knopf-Kombinationen

**Beispiel bei 3 Knöpfen:**
- `000` (0): Keine Knöpfe
- `001` (1): Nur Knopf 0
- `010` (2): Nur Knopf 1
- `011` (3): Knöpfe 0 und 1
- ... bis `111` (7)

#### 3. Toggle-Operationen

```python
for i, k in enumerate(knoepfe):
    if maske & (1 << i):
        for idx in k:
            if idx < n_lichter:
                zustand[idx] ^= 1
```

**XOR Toggle:**
- `x ^= 1`: Flippt Bit (0 → 1, 1 → 0)
- Simuliert Toggle-Verhalten der Knöpfe
- Jeder Knopf wird 0 oder 1 mal gedrückt (mehr ist sinnlos)

**Warum nur 0 oder 1 mal?**
- Toggle zweimal = zurück zum Original
- Über GF(2) (Modulo 2) arbeiten
- Optimum immer bei ≤ 1 Druck pro Knopf

#### 4. Bit-Zählung

```python
beste = min(beste, maske.bit_count())
```

**bit_count():**
- Python 3.10+ Methode
- Zählt Anzahl der 1-Bits
- Entspricht Anzahl gedrückter Knöpfe
- Effizienter als manuelle Zählung

**Beispiel:** `maske = 5 = 0b101` → `bit_count() = 2`

#### 5. Matrix-Aufbau für MILP

```python
matrix = np.zeros((n_zaehler, n_knoepfe))
for i, z in enumerate(knoepfe):
    matrix[[j for j in z if j < n_zaehler], i] = 1
```

**Matrix-Struktur:**
- Zeilen = Zähler
- Spalten = Knöpfe
- `matrix[j][i] = 1` wenn Knopf i Zähler j erhöht

**NumPy Fancy Indexing:**
- `matrix[[j1, j2, ...], i] = 1` setzt mehrere Zeilen auf einmal
- Kompakter als verschachtelte Schleifen

#### 6. MILP Problem-Definition

```python
result = milp(
    c=np.ones(n_knoepfe),                    # Zielfunktion: minimiere sum(x)
    constraints=LinearConstraint(matrix, ziel_joltage, ziel_joltage),  # A*x = b
    bounds=Bounds(0, np.inf),                # x_i ≥ 0
    integrality=np.ones(n_knoepfe)          # x_i ∈ ℤ
)
```

**Parameter:**
- `c`: Koeffizienten der Zielfunktion (alle 1 → minimiere Summe)
- `constraints`: Gleichheitsbedingungen (Matrix * x = Ziel)
- `bounds`: x ≥ 0 (keine negativen Drücke)
- `integrality`: Alle Variablen sind Integer

**Mathematisch:**
```
Minimiere:  x₁ + x₂ + ... + xₙ
Unter:      A * x = b
            x ≥ 0
            x ∈ ℕⁿ
```

### Beispiel-Durchlauf

**Eingabe Teil 1:**
```
[.##.] (3) (1,3) (2) (2,3) (0,2) (0,1)
```

**Ziel:** `[0,1,1,0]` (4 Lichter)
**Knöpfe:** 6 Knöpfe

**Optimale Lösung:**
- Knopf 4 `(0,2)`: Toggle Lichter 0 und 2 → `[1,0,1,0]`
- Knopf 5 `(0,1)`: Toggle Lichter 0 und 1 → `[0,1,1,0]` ✓
- **Ergebnis:** 2 Drücke

**Brute-Force findet:**
- Testet alle 2^6 = 64 Kombinationen
- Findet Maske `0b110000` (Knöpfe 4 und 5)
- `bit_count(0b110000) = 2`

**Eingabe Teil 2:**
```
[.##.] (3) (1,3) (2) (2,3) (0,2) (0,1) {3,5,4,7}
```

**Matrix:**
```
Zähler \ Knopf:  0  1  2  3  4  5
Zähler 0:        0  0  0  0  1  1
Zähler 1:        0  1  0  0  0  1
Zähler 2:        0  0  1  1  1  0
Zähler 3:        1  1  0  1  0  0
```

**MILP löst:**
```
x₀ + x₁ + x₂ + x₃ + x₄ + x₅ → min
x₄ + x₅ = 3
x₁ + x₅ = 5
x₂ + x₃ + x₄ = 4
x₀ + x₁ + x₃ = 7
x ≥ 0, x ∈ ℕ⁶
```

**Optimum:** `x = [1, 3, 0, 3, 1, 2]` → Summe = 10

### Komplexität

**Teil 1 (Brute-Force):**
- Zeit: O(2^n * n * m) wobei n = Knöpfe, m = Lichter pro Knopf
- Platz: O(m) für Zustand
- Praktisch: n ≤ 13 → 2^13 = 8192 → sehr schnell

**Teil 2 (MILP):**
- Zeit: Exponentiell im schlimmsten Fall, praktisch schnell
- Branch-and-Bound Algorithmus
- SciPy's HiGHS Solver ist optimiert
- Für kleine Probleme (< 20 Variablen) sehr effizient

**Gesamt:**
- ~0.3 Sekunden für alle 191 Maschinen
- Teil 1 dominiert (mehr Kombinationen pro Maschine)

### Besonderheiten

**GF(2) vs. ℕ:**
- Teil 1: Galois-Feld mit 2 Elementen (Modulo 2)
- Teil 2: Natürliche Zahlen
- Völlig unterschiedliche mathematische Strukturen
- Unterschiedliche Lösungsansätze nötig

**Brute-Force Berechtigung:**
- Bei kleinem n ist Brute-Force oft optimal
- Einfacher zu implementieren als Gaussian Elimination
- Keine numerischen Stabilitätsprobleme
- Code ist kürzer und lesbarer

**MILP Notwendigkeit:**
- Einfaches LP (ohne Integer-Constraint) liefert falsche Ergebnisse
- Rundung von LP-Lösung ist nicht optimal
- Echtes ILP-Solving erforderlich
- SciPy's MILP garantiert Optimalität

**Bit-Operationen:**
- `1 << n`: Bit-Shift für 2^n
- `x & (1 << i)`: Test ob Bit i gesetzt
- `x ^= 1`: XOR für Toggle
- Effizient und elegant

**NumPy Fancy Indexing:**
- `matrix[[j1, j2], i] = 1`: Mehrere Zeilen auf einmal setzen
- Vermeidet verschachtelte Schleifen
- Pythonischer Code-Stil

**Code-Länge:**
- Nur 50 Zeilen für beide Teile
- Ursprünglich 121 Zeilen mit Gaussian Elimination
- Einfachheit > Komplexität

### Alternative Ansätze

**Teil 1:**
1. **Gaussian Elimination über GF(2):**
   - Theoretisch eleganter
   - Praktisch: 3x mehr Code
   - Gleiche Laufzeit
   - Komplexer zu implementieren

2. **Greedy:**
   - Funktioniert nicht
   - Problem ist NP-komplett
   - Keine Greedy-Strategie garantiert Optimum

**Teil 2:**
1. **LP mit Rundung:**
   - Schneller, aber inkorrekt
   - Lieferte ~11000 statt 18981
   - Rundungsfehler akkumulieren

2. **Gaussian Elimination mit Optimierung:**
   - Sehr komplex
   - Unterbestimmte Systeme schwierig
   - Keine Garantie für L1-Optimum

3. **Pulp/OR-Tools:**
   - Würde auch funktionieren
   - SciPy bereits vorhanden
   - Keine zusätzliche Dependency nötig

### Performance-Hinweise

**Teil 1 Optimierungen:**
- Early Exit bei Lösung mit 0 Drücken
- Pruning bei beste > threshold
- Nicht nötig bei aktueller Problemgröße

**Teil 2 Optimierungen:**
- MILP Solver-Parameter tuning
- Warm-Start mit LP-Lösung
- Nicht nötig - bereits sehr schnell

**Praktische Laufzeit:**
- Teil 1: ~0.2s
- Teil 2: ~0.1s
- Gesamt: ~0.3s
- Vollkommen akzeptabel für AoC
