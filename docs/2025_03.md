# Tag 03 - Greedy-Auswahl größter Ziffern

## Aufgabe

Aus einem String von Ziffern (der "Bank") die N größten Ziffern auswählen und zur größtmöglichen Zahl anordnen.

- **Teil 1:** 2 Batterien (Ziffern) auswählen
- **Teil 2:** 12 Batterien (Ziffern) auswählen

## Lösung

### Eingabeformat

Jede Zeile enthält einen String von Ziffern (0-9).

Beispiel: `"8675309"` → Wähle die N größten Ziffern aus

### Algorithmus

Der Kern ist ein **Greedy-Algorithmus**, der schrittweise die lokal beste Wahl trifft:

```python
def solver(bank:str, batterien:int)->int:
    auswahl = ""
    for i in range(1, batterien):
        batterie = max(bank[:-(batterien - i)])
        bank = bank.split(batterie, 1)[1]
        auswahl += batterie
    return int(auswahl+max(bank))
```

### Funktionsweise

#### 1. Iterative Auswahl

**Für jede Position der Ergebnis-Zahl (außer der letzten):**

```python
for i in range(1, batterien):
```

- Bei `batterien=2`: 1 Iteration (eine Ziffer wählen, dann Rest)
- Bei `batterien=12`: 11 Iterationen

#### 2. Suchbereich berechnen

```python
batterie = max(bank[:-(batterien - i)])
```

**Logik:**
- `batterien - i` = Anzahl verbleibender Ziffern nach dieser Wahl
- `bank[:-(batterien - i)]` = Suchbereich (lässt genug Ziffern für später übrig)
- `max(...)` = Größte Ziffer im Suchbereich

**Beispiel:** `bank="8675309"`, `batterien=2`, `i=1`
- `batterien - i = 1` (eine Ziffer muss noch übrig bleiben)
- `bank[:-1] = "867530"` (letzte Ziffer ausgeschlossen)
- `max("867530") = "8"`

#### 3. String reduzieren

```python
bank = bank.split(batterie, 1)[1]
```

**Logik:**
- Teilt beim **ersten Vorkommen** der gewählten Ziffer
- Nimmt nur den Teil **nach** der Ziffer: `[1]`
- Alle Ziffern **vor und inklusive** der gewählten werden verworfen

**Beispiel:** `bank="8675309"`, `batterie="8"`
- `"8675309".split("8", 1) = ["", "675309"]`
- `bank = "675309"`

#### 4. Ziffer zur Auswahl hinzufügen

```python
auswahl += batterie
```

Baut schrittweise die Ergebnis-Zahl als String auf.

#### 5. Letzte Ziffer

```python
return int(auswahl+max(bank))
```

Nach der Schleife bleibt genau die richtige Anzahl Ziffern übrig. Nimm das Maximum davon als letzte Ziffer.

### Beispiel-Durchlauf

**Eingabe:** `bank="8675309"`, `batterien=2`

**Iteration 1 (i=1):**
- Suchbereich: `"867530"` (letzte Ziffer reserviert)
- Gewählt: `"8"` (Maximum)
- Neue Bank: `"675309"` (alles nach der "8")
- Auswahl: `"8"`

**Nach Schleife:**
- Rest: `"675309"`
- Letzte Ziffer: `max("675309") = "9"`
- Ergebnis: `int("89") = 89`

**Eingabe:** `bank="321"`, `batterien=2`

**Iteration 1 (i=1):**
- Suchbereich: `"32"` (eine Ziffer reserviert)
- Gewählt: `"3"` (Maximum)
- Neue Bank: `"21"` (alles nach der "3")
- Auswahl: `"3"`

**Nach Schleife:**
- Rest: `"21"`
- Letzte Ziffer: `max("21") = "2"`
- Ergebnis: `int("32") = 32`

### Warum funktioniert der Greedy-Ansatz?

**Greedy-Prinzip:** Wähle immer die größte verfügbare Ziffer für die aktuelle Position (von links nach rechts).

**Korrektheit:**
1. **Hohe Positionen sind wichtiger:** Eine "9" an erster Stelle schlägt jede Kombination mit kleinerer erster Ziffer
2. **Suchbereich garantiert Lösbarkeit:** Durch `bank[:-(batterien-i)]` wird sichergestellt, dass immer genug Ziffern für spätere Positionen übrig bleiben
3. **Lokale Optimalität = Globale Optimalität:** Bei diesem Problem führt die lokal beste Wahl (größte verfügbare Ziffer) zur global besten Lösung

### Komplexität

- **Zeit:** O(n * m) wobei n = Anzahl Zeilen, m = Länge der Bank
  - Pro Iteration: `max()` ist O(m), `split()` ist O(m)
  - `batterien` Iterationen pro Zeile
- **Platz:** O(m) für String-Operationen

### Besonderheiten

- **String-Slicing mit negativem Index:** `bank[:-(batterien-i)]` für Suchbereich
- **split() mit Limit:** `split(batterie, 1)` trennt nur beim ersten Vorkommen
- **Greedy ohne Backtracking:** Einmal gewählte Ziffer wird nie revidiert
- **Keine explizite Position:** Algorithmus arbeitet durch Verkleinerung des Strings
