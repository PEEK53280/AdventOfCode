# Tag 01 - Rundlauf-Simulation

## Aufgabe

Simulation einer kreisförmigen Strecke mit 100 Positionen. Bewegungen erfolgen nach links (L) oder rechts (R) mit einer bestimmten Distanz.

## Lösung

### Eingabeformat

Jede Zeile enthält:
- Richtung: `L` (links) oder `R` (rechts)
- Distanz: Anzahl der Schritte (als Zahl nach dem Richtungsbuchstaben)

Beispiel: `L350` bedeutet 350 Schritte nach links.

### Algorithmus

**Startposition:** 50 (Mitte der 100-Positionen-Strecke)

**Für jede Bewegung:**

1. **Parse Eingabe:**
   ```python
   richtung, runden, distanz = zeile[0], *divmod(int(zeile[1:]), 100)
   ```
   - `zeile[0]`: Richtung (L/R)
   - `divmod(int(zeile[1:]), 100)`: Teilt die Distanz in volle Runden und Rest-Distanz
   - Beispiel: `350 → divmod(350, 100) → (3, 50)` = 3 Runden + 50 Schritte

2. **Bewegung nach links (L):**
   ```python
   runden += int(distanz >= position > 0)
   position = (position - distanz) % 100
   ```
   - Prüfe ob eine zusätzliche Runde (Überlauf) entsteht
   - Neue Position: `(position - distanz) % 100`

3. **Bewegung nach rechts (R):**
   ```python
   runden += int(distanz >= 100 - position)
   position = (position + distanz) % 100
   ```
   - Prüfe ob eine zusätzliche Runde entsteht
   - Neue Position: `(position + distanz) % 100`

4. **Zähle Ergebnisse:**
   - **Lösung 1:** Anzahl der Male, dass Position 0 erreicht wird
   - **Lösung 2:** Gesamtzahl der Runden

### Datenstrukturen

- `position`: Integer (0-99) - Aktuelle Position auf der Kreisbahn
- `runden`: Integer - Anzahl voller Umläufe
- `distanz`: Integer - Schritte innerhalb einer Runde

### Komplexität

- **Zeit:** O(n) - Eine Iteration durch alle Eingabezeilen
- **Platz:** O(1) - Nur konstante Variablen

### Besonderheiten

- **Modulo-Arithmetik:** `% 100` für zyklische Position
- **divmod():** Effiziente Berechnung von Runden + Rest-Distanz
- **Clever:** Runden-Überlauf wird durch Bedingungen geprüft, nicht durch explizite Berechnung
