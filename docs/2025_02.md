# Tag 02 - String-Muster-Analyse

## Aufgabe

Analysiere Zahlen (als Strings) auf wiederkehrende Muster:
- **Teil 1:** Finde Zahlen, deren erste Hälfte gleich der zweiten Hälfte ist
- **Teil 2:** Finde Zahlen, die aus wiederholten Mustern bestehen

## Lösung

### Eingabeformat

Bereiche von Zahlen, getrennt durch Kommas:
- Format: `start-ende,start-ende,...`
- Beispiel: `100-200,500-600` → Alle Zahlen von 100-200 und 500-600

### Algorithmus

#### 1. Zahlen generieren

```python
def werte_generieren():
    return (str(wert) for element in aufgabe.text.split(",")
            for start, ende in [map(int, element.split("-"))]
            for wert in range(start, ende + 1))
```

- **Generator**: Speichersparend, generiert Zahlen on-the-fly
- **Nested Loop**: Für jeden Bereich → Alle Zahlen als Strings

#### 2. Aufgabe 1 - Palindrom-Hälften

```python
def aufgabe1(data):
    if len(data) % 2 == 0:
        aufgabe.loesung1 += int(data) if data[:len(data) // 2] == data[len(data) // 2:] else 0
```

**Logik:**
1. Prüfe ob Länge gerade ist
2. Teile String in zwei Hälften: `data[:len//2]` und `data[len//2:]`
3. Wenn gleich → Addiere Zahl zur Lösung

**Beispiel:**
- `"1221"` → `"12"` == `"21"` → ❌
- `"1212"` → `"12"` == `"12"` → ✅

#### 3. Aufgabe 2 - Wiederholende Muster

```python
def aufgabe2(data):
    for anzahl in range(2, len(data) + 1):
        if len(data) % anzahl != 0:
            continue
        laenge = len(data) // anzahl
        if data[:laenge] * anzahl == data:
            aufgabe.loesung2 += int(data)
            break
```

**Logik:**
1. Iteriere durch mögliche Anzahl von Wiederholungen (2 bis Länge)
2. Skip wenn Länge nicht durch Anzahl teilbar
3. Berechne Pattern-Länge: `len(data) // anzahl`
4. Prüfe: `pattern * anzahl == data`
5. Bei erstem Match → Addiere und break (kleinste Pattern-Anzahl zählt)

**Beispiel:**
- `"123123"` → Pattern `"123"` * 2 → ✅
- `"1111"` → Pattern `"1"` * 4 → ✅ (aber findet `"11"` * 2 zuerst)

### Optimierungen

**String-Multiplikation:**
- `data[:laenge] * anzahl` ist sehr effizient in Python
- Alternativ: Loop mit `all()` wäre langsamer

**Generator statt Liste:**
- Speichert nicht alle Zahlen im RAM
- Prozessiert on-the-fly

**Early Break:**
- In `aufgabe2()` wird bei erstem Match abgebrochen
- Findet immer die kleinste gültige Anzahl

### Komplexität

- **Zeit:** O(n * m) wobei n = Anzahl Zahlen, m = durchschnittliche Länge
- **Platz:** O(1) durch Generator (ohne Materialisierung)

### Besonderheiten

- **Generator-Expression**: Speichereffizient für große Bereiche
- **String-Slicing**: Pythons effiziente String-Operationen
- **Ternary Operator**: Kompakte Conditional-Zuweisung
